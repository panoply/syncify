[
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/spx/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/spx/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/spx/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/syncify/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/syncify/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/syncify/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/syncify/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/syncify/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/syncify/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Getting Help",
    "heading": "Getting Help",
    "content": "Syncify currently doesn't have a centralized hub where developers and users can gather. Given its recent introduction, setting up a dedicated Discord or chat platform isn't deemed essential at this time, though this could change in the future. However, if you're seeking guidance or wish to connect with others utilizing Syncify, you can engage with diverse developers across various communities and online forums.",
    "url": "/getting-help#getting-help"
  },
  {
    "title": "Getting Help",
    "heading": "Shopify Developers",
    "content": "[Join the Discord](https://discord.gg/shopify-developers-597504637167468564)",
    "url": "/getting-help#shopify-developers"
  },
  {
    "title": "Getting Help",
    "heading": "Odestry Community",
    "content": "[Join the Discord](https://discord.gg/blanklob-community-983602196493004820)",
    "url": "/getting-help#odestry-community"
  },
  {
    "title": "Getting Help",
    "heading": "Github Repository",
    "content": "[Submit Issue](https://github.com/panoply/syncify/issues/new)",
    "url": "/getting-help#github-repository"
  },
  {
    "title": "Getting Help",
    "heading": "X / Formerly Twitter",
    "content": "[@niksavvidis](https://x.com/niksavvidis)",
    "url": "/getting-help#x--formerly-twitter"
  },
  {
    "title": "HOT",
    "heading": "Options",
    "content": "",
    "url": "/configure/hot#options"
  },
  {
    "title": "HOT",
    "heading": "Server",
    "content": "The static server for assets - This will be written in the HOT snippet",
    "url": "/configure/hot#server"
  },
  {
    "title": "HOT",
    "heading": "Socket",
    "content": "Websocket port - This will be written in the HOT snippet",
    "url": "/configure/hot#socket"
  },
  {
    "title": "HOT",
    "heading": "layouts",
    "content": "A string list of Liquid template layout names used in your theme which should have the hot snippet injected.",
    "url": "/configure/hot#layouts"
  },
  {
    "title": "HOT",
    "heading": "Inject",
    "content": "Whether or not Syncify should inject the required HOT snippet at runtime layout/s. When false you will need to manually place the hot.js.liquid snippet into your theme. By default when running --hot Syncify will check your layout/s for the hot snippet and if it's not present then syncify will inject it and invoke an upload of the layouts.",
    "url": "/configure/hot#inject"
  },
  {
    "title": "HOT",
    "heading": "method",
    "content": "Which live reload method should Syncify use. Setting this to hot will apply HOT reloading to assets and views with automatic refresh upon changes. Using the refresh option will invokes a full page refresh after changes have been applied",
    "url": "/configure/hot#method"
  },
  {
    "title": "HOT",
    "heading": "strategy",
    "content": "When using the replace strategy will execute fragment swaps use replaceWith instead of morphs when executing HOT reloads. It works almost identical to hydrate but respects DOM mutations. If you are leveraging a framework like Stimulus or Alpine, then choose this strategy.",
    "url": "/configure/hot#strategy"
  },
  {
    "title": "HOT",
    "heading": "scroll",
    "content": "Scroll position between reloads. Defaults to preserve but can also be set to top. When using top scroll position will move to the top of page between refreshes.",
    "url": "/configure/hot#scroll"
  },
  {
    "title": "Shared Schema",
    "heading": "Shared Schema",
    "content": "The internal structure of shared schema files uses a simple key → value (object) pattern, similar to how we define presets in section schemas. Importing shared schemas into {liquid} {% schema %} tags is made possible using a reference $ref key and an injection value expression, allowing for the selective inclusion of different structures within schema files.",
    "url": "/features/shared-schema#shared-schema"
  },
  {
    "title": "Shared Schema",
    "heading": "Motivation",
    "content": "In theme development, we often need to reuse schema across multiple sections. However, this capability is not supported by Shopify, which leaves developers at the mercy of replication methods (i.e: copy/paste), potentially leading to inconsistencies. Syncify's shared schema capability addresses this issue by allowing developers to isolate the schema structures they intend to reuse across multiple sections.",
    "url": "/features/shared-schema#motivation"
  },
  {
    "title": "Shared Schema",
    "heading": "Usage",
    "content": "The above example is the default configuration the Syncify will adhere to using, wherein shared schema files are to exist within a source/schema directory. Shared Schema files can use .schema or .json extension, both are valid and will be interepreted as JSON with the difference being that files using the .schema extension support intellisense features and generally the preferred format to apply is .schema as the VSCode Liquid extension has built-in intellisense support for files using the .schema extension.",
    "url": "/features/shared-schema#usage"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema Files",
    "content": "There are several different structures you can use for defining settings and blocks within shared schema files. Syncify describes each shared schema structure as follows:",
    "url": "/features/shared-schema#schema-files"
  },
  {
    "title": "Shared Schema",
    "heading": "Schema $refs",
    "content": "",
    "url": "/features/shared-schema#schema-refs"
  },
  {
    "title": "Shared Schema",
    "heading": "Setting Singleton",
    "content": "",
    "url": "/features/shared-schema#setting-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Spread",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-spread"
  },
  {
    "title": "Shared Schema",
    "heading": "Settings Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#settings-collection"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Singleton",
    "content": "",
    "url": "/features/shared-schema#block-singleton"
  },
  {
    "title": "Shared Schema",
    "heading": "Block Collection",
    "content": "Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output. Below is an example of a shared schema settings spread. The approach accepts an array list of settings and when referenced in sections will spread the output.",
    "url": "/features/shared-schema#block-collection"
  },
  {
    "title": "HOT Reloading",
    "heading": "HOT Reloading",
    "content": "Live reloading (otherwise known as HOT Reloads ) is supported in watch mode. Syncify leverages websocket's, XHR and statically served endpoints to provide this capability with zero configuration or the need to install or setup additional tooling. No extensions and no complexities. Syncify will listen for messages sent via websocket on the client and carry out HOT replacements of Assets, Sections, Snippets, Layouts and Templates without triggering full-page refreshes. HOT Reloads can be enabled by passing the --hot flag via the CLI. The Syncify HOT reload tends to be considerably faster than using the Shopify CLI.",
    "url": "/features/hot-reloading#hot-reloading"
  },
  {
    "title": "HOT Reloading",
    "heading": "Assets",
    "content": "SASS/CSS, TypeScript/JavaScript and SVG asset file types are HOT reloaded by swapping out the URL's or containing source with localhost equivalents served statically by Syncify.",
    "url": "/features/hot-reloading#assets"
  },
  {
    "title": "HOT Reloading",
    "heading": "Section",
    "content": "Dynamic sections, static sections of a combination of both are fetched via the Ajax [Section rendering API](https://shopify.dev/docs/api/section-rendering). Replacements are applied to fragments in real-time and surrounding nodes are left intact.",
    "url": "/features/hot-reloading#section"
  },
  {
    "title": "HOT Reloading",
    "heading": "Others",
    "content": "In order to provide HOT replacements Syncify employs a mild form of DOM hydration. Snippets, templates and Liquid/JSON layout files will reflect changes near instantly and upto 10x faster than invoking a hard-refresh.",
    "url": "/features/hot-reloading#others"
  },
  {
    "title": "HOT Reloading",
    "heading": "CLI Usage",
    "content": "",
    "url": "/features/hot-reloading#cli-usage"
  },
  {
    "title": "HOT Reloading",
    "heading": "Default Options",
    "content": "",
    "url": "/features/hot-reloading#default-options"
  },
  {
    "title": "HOT Reloading",
    "heading": "Programmatic Control",
    "content": "Running in HOT mode will result in Syncify injecting a snippet into layouts. The snippet is the socket receiver that is responsible for executing replacements/morphs and exposes programmatic control for developers who can to customize or hook into the HOT reload rendering cycles.",
    "url": "/features/hot-reloading#programmatic-control"
  },
  {
    "title": "Introduction",
    "heading": "What is Syncify?",
    "content": "Syncify is a specialized tool designed for Shopify theme development, positioning itself as an advanced alternative to the Shopify CLI. It offers a suite of features aimed at enhancing productivity through a structured yet flexible approach to store development.",
    "url": "/what-is-syncify#what-is-syncify"
  },
  {
    "title": "Introduction",
    "heading": "Key Features",
    "content": "",
    "url": "/what-is-syncify#key-features"
  },
  {
    "title": "Introduction",
    "heading": "Developer Driven Innovation",
    "content": "Syncify embodies the spirit of developer empowerment within the Shopify ecosystem. It's not merely a tool but a symbol of resistance against inadequate corporate solutions, advocating for a development environment where community-driven innovation thrives.",
    "url": "/what-is-syncify#developer-driven-innovation"
  },
  {
    "title": "Introduction",
    "heading": "Rationale",
    "content": "Syncify is designed for developers who seek a more sophisticated, performant and adaptable toolkit for Shopify theme development. By choosing Syncify, developers are not just selecting a tool; they're adopting a customizable workflow that supports advanced development practices, encourages efficiency, and aligns with the nuanced needs of professional Shopify theme development.",
    "url": "/what-is-syncify#rationale"
  },
  {
    "title": "Introduction",
    "heading": "Complexity Management",
    "content": "For projects that grow in complexity, Syncify's ability to handle multiple themes and custom directory structures becomes invaluable. It allows developers to maintain organization and efficiency as projects scale.",
    "url": "/what-is-syncify#complexity-management"
  },
  {
    "title": "Introduction",
    "heading": "Enhanced Control",
    "content": "Developers often require fine-grained control over their development process. Syncify provides this through its detailed logging, custom path mappings, and extensive synchronization options, which are not as comprehensively available in more basic tools like the Shopify CLI.",
    "url": "/what-is-syncify#enhanced-control"
  },
  {
    "title": "Introduction",
    "heading": "Productivity and Speed",
    "content": "With features like hot reloading and intelligent syncing, Syncify reduces the wait times associated with seeing changes live. This immediate feedback loop can significantly speed up the development cycle, allowing for quicker iterations and testing.",
    "url": "/what-is-syncify#productivity-and-speed"
  },
  {
    "title": "Introduction",
    "heading": "Flexibility for Diverse Workflows",
    "content": "Not all Shopify projects are created equal. Syncify's design acknowledges this by supporting integration with other tools and processes, making it adaptable to various development methodologies and existing workflows.",
    "url": "/what-is-syncify#flexibility-for-diverse-workflows"
  },
  {
    "title": "Introduction",
    "heading": "Future-Proofing:",
    "content": "As e-commerce evolves, so do the tools needed to manage it. Syncify's extensible nature suggests it's built with future developments in mind, potentially making it a long-term investment in a developer's toolkit.",
    "url": "/what-is-syncify#future-proofing"
  },
  {
    "title": "Introduction",
    "heading": "Shopify CLI Contrast:",
    "content": "When compared to the Shopify CLI, Syncify offers a departure from the conventional single-structure methodology. This flexibility can significantly enhance the development process for those who find the rigid structure of the CLI limiting.",
    "url": "/what-is-syncify#shopify-cli-contrast"
  },
  {
    "title": "Syncify CLI",
    "heading": "Syncify CLI",
    "content": "",
    "url": "/usage/syncify-cli#syncify-cli"
  },
  {
    "title": "Overview",
    "heading": "Overview",
    "content": "",
    "url": "/cli/overview#overview"
  },
  {
    "title": "Overview",
    "heading": "Interface",
    "content": "",
    "url": "/cli/overview#interface"
  },
  {
    "title": "Overview",
    "heading": "Colors",
    "content": "",
    "url": "/cli/overview#colors"
  },
  {
    "title": "Overview",
    "heading": "Aliases",
    "content": "",
    "url": "/cli/overview#aliases"
  },
  {
    "title": "Overview",
    "heading": "Grouping",
    "content": "",
    "url": "/cli/overview#grouping"
  },
  {
    "title": "Overview",
    "heading": "Info",
    "content": "",
    "url": "/cli/overview#info"
  },
  {
    "title": "Overview",
    "heading": "Errors",
    "content": "",
    "url": "/cli/overview#errors"
  },
  {
    "title": "Overview",
    "heading": "Warnings",
    "content": "",
    "url": "/cli/overview#warnings"
  },
  {
    "title": "Authentication",
    "heading": "Authentication",
    "content": "After installing Syncify you will need to configure a connection to your Shopify store. Syncify requires you provide either an Admin API Access Token (recommended) or API Key and Secret as credentials. You will need to create a private app to obtain this information from Shopify. If you are coming from [Theme Kit](https://shopify.dev/themes/tools/theme-kit) you might be able to port those settings but it is recommended that you generate API access information specifically for usage with Syncify.",
    "url": "/setup/authentication#authentication"
  },
  {
    "title": "Authentication",
    "heading": "Scopes",
    "content": "You need to provide Syncify read and write access to a couple of admin endpoints so it can perform operations. Below are the required scopes you will need to enable within in your private app.",
    "url": "/setup/authentication#scopes"
  },
  {
    "title": "Authentication",
    "heading": "Credentials",
    "content": "Shop credentials can be stored within a .env or .env.syncify.json file. You can also provide credentials at runtime using process.env variables. The preferred approach is to store this information within a .env file. Syncify supports 3 different credential storage options.",
    "url": "/setup/authentication#credentials"
  },
  {
    "title": "Authentication",
    "heading": "Using .ENV file",
    "content": "Using multiple stores API Authorization",
    "url": "/setup/authentication#using-env-file"
  },
  {
    "title": "Checklist",
    "heading": "Checklist",
    "content": "If you've followed the authentication and references steps, your theme will be ready for Syncify. This page aims to help showcase how things might look and provide you with some additional context.",
    "url": "/setup/checklist#checklist"
  },
  {
    "title": "Checklist",
    "heading": "todo",
    "content": "",
    "url": "/setup/checklist#todo"
  },
  {
    "title": "References",
    "heading": "References",
    "content": "The option accepts an object or array type. Each item will hold reference to your shopify store/s and their theme/s. For each store you define, you will provide the shop name, theme target name and id. The themes object uses a key > value structure, where the key represent a theme name (target) and the value a theme id. The information you provide to this option can be used via the CLI when targeting and executing operations. Please refer to the commands portion of this readme for more information on CLI usage.",
    "url": "/setup/references#references"
  },
  {
    "title": "Transforms",
    "heading": "Using Transforms",
    "content": "In Syncify, asset files can be transformed before being written to the defined output directory and uploaded to your Shopify store. The transform option provides users with control of the \"asset pipeline\" and Syncify exposes configuration wrappers for handling files together with modern developer tooling.",
    "url": "/usage/using-transforms#using-transforms"
  },
  {
    "title": "Transforms",
    "heading": "Script",
    "content": "Syncify exposes a script transform option which supports TypeScript (.ts and .tsx) and/or JavaScript (.js and .jsx) bundling using [ESBuild](https://esbuild.github.io/). Script transforms use a pre-defined set of processing configurations and will produce lean JavaScript bundles designed to work seamlessly in development mode or when leveraging HOT reloads. Syncify will also apply refinements to distribution bundles focused on performance when generating production builds for your Shopify theme.",
    "url": "/usage/using-transforms#script"
  },
  {
    "title": "Transforms",
    "heading": "Bundling TypeScript",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/using-transforms#bundling-typescript"
  },
  {
    "title": "Transforms",
    "heading": "Styles",
    "content": "",
    "url": "/usage/using-transforms#styles"
  },
  {
    "title": "Transforms",
    "heading": "TAILWIND IS NOT YET SUPPORT",
    "content": "Style transforms help alleviate the complexities sometimes involved in setting up these tools so you can easily process asset specific stylesheets or generate output as a snippet within <style></style> tags.",
    "url": "/usage/using-transforms#tailwind-is-not-yet-support"
  },
  {
    "title": "Transforms",
    "heading": "SASS Support",
    "content": "Syncify provides SCSS/SASS transform support for .scss and .sass file types using [Dart SASS](#). Using SASS required you to install the Dart module as a development dependency in your project. Syncify will complain if you try to use SASS transforms without Dart SASS installed.",
    "url": "/usage/using-transforms#sass-support"
  },
  {
    "title": "Transforms",
    "heading": "Tailwind Support ~ COMING SOON",
    "content": "Syncify supports TailwindCSS for CSS processing. If you require transform support for Tailwind, you need to install the TailwindCSS module as a development dependency in your project. Syncify will ignore Tailwind class name occurrences without the module installed.",
    "url": "/usage/using-transforms#tailwind-support--coming-soon"
  },
  {
    "title": "Transforms",
    "heading": "PostCSS Support",
    "content": "Please note: If you are using Syncify to compile SASS files, then by default the transformed CSS will be passed to PostCSS.",
    "url": "/usage/using-transforms#postcss-support"
  },
  {
    "title": "Transforms",
    "heading": "Usage",
    "content": "In the below example we are generating multiple stylesheets and compiling both SCSS and CSS file types. The example illustrates how one can leverage Syncify together with [Dart SASS](#), [PostCSS](#) and additional node modules like the Bootstrap framework.",
    "url": "/usage/using-transforms#usage"
  },
  {
    "title": "Style Transform",
    "heading": "Style",
    "content": "The style transform option simplifies the process of bundling CSS, SCSS, or SASS by integrating compilers such as Dart SASS, PostCSS, and Tailwind. This feature offers developers a familiar configuration control, mirroring what you might set up manually, but with added ease.",
    "url": "/options/transform/style#style"
  },
  {
    "title": "Style Transform",
    "heading": "Options",
    "content": "",
    "url": "/options/transform/style#options"
  },
  {
    "title": "Style Transform",
    "heading": "Example Usage",
    "content": "Passing an array of style configurations.",
    "url": "/options/transform/style#example-usage"
  },
  {
    "title": "Pages",
    "heading": "Markdown Pages",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-pages"
  },
  {
    "title": "Pages",
    "heading": "Remote and Local sources",
    "content": "By default, syncify will perform safe synchronization. The safeSync option instructs syncify to pull down remote versions before uploading local ones in watch and upload modes. This operation ensures that you do not overwrite page content in situations where changes have been applied in your store since the last sync was performed on your local machine. Syncify will prompt you when misalignment is detected and allow you to pull in the remote versions.",
    "url": "/features/markdown-pages#remote-and-local-sources"
  },
  {
    "title": "Pages",
    "heading": "Markdown Support",
    "content": "Pages can be written in markdown, Syncify will transform .md page files into valid HTML markup when syncing. Markdown pages are parsed and transformed using the the powerful markdown-it and support Github flavored markdown syntax. In addition to Markdown → HTML generation, Syncify can also perform reversed conversion (HTML → Markdown). Using the importLanguage option, any time a remote to local alignment is carried out, files will be written in markdown.",
    "url": "/features/markdown-pages#markdown-support"
  },
  {
    "title": "Pages",
    "heading": "Frontmatter Support",
    "content": "You can pass frontmatter data in page files. Page frontmatter can be used to control per-page publishing settings and allows for additional request payloads to be passed. Syncify supports a modest schema structure for page frontmatter.",
    "url": "/features/markdown-pages#frontmatter-support"
  },
  {
    "title": "Installation",
    "heading": "Installation",
    "content": "Syncify is distributed as both an ESM and CJS module. It is recommended that you install as a development dependency in your project opposed to installing globally. Please consider choosing and adopting pnpm as your package manager for most optimal usage.",
    "url": "/setup/installation#installation"
  },
  {
    "title": "Installation",
    "heading": "PNPM",
    "content": "",
    "url": "/setup/installation#pnpm"
  },
  {
    "title": "Installation",
    "heading": "NPM",
    "content": "",
    "url": "/setup/installation#npm"
  },
  {
    "title": "Installation",
    "heading": "YARN",
    "content": "",
    "url": "/setup/installation#yarn"
  },
  {
    "title": "Installation",
    "heading": "BUN",
    "content": "",
    "url": "/setup/installation#bun"
  },
  {
    "title": "Installation",
    "heading": "Schema Stores",
    "content": "Syncify provides JSON Schema Store references for usage in JSON files that contain a $schema property or within text editors like [VSCode](https://code.visualstudio.com/) which support external schema store association. The JSON Schema store is helpful for users who prefer .json configurations or are setting config options within their package.json file via the syncify config key.",
    "url": "/setup/installation#schema-stores"
  },
  {
    "title": "Installation",
    "heading": "VSCode Usage",
    "content": "Developers using the VSCode text editor can enable the JSON Schema within the projects workspace or global settings. If you are using the vscode-liquid extension these references are automatically applied for you, however for the animals using Shopify theme check, you'll need to extend.",
    "url": "/setup/installation#vscode-usage"
  },
  {
    "title": "Config File",
    "heading": "Config Files",
    "content": "Syncify supports syncify.config.ts and package.json configurations. Depending on your preference, either method suffices and no restrictions are imposed. If you are defining options within your projects package.json file you can assign options to the syncify → config property, whereas using a syncify.config.js or syncify.config.ts file you'll need to apply options on the export.",
    "url": "/usage/config-files#config-files"
  },
  {
    "title": "Config File",
    "heading": "Supported File Types",
    "content": "Syncify supports JSON, JSONC, JavaScript and TypeScript external configuration files. The TypeScript syncify.config.ts type is the recommended configuration file to use along the defaultConfig named import.",
    "url": "/usage/config-files#supported-file-types"
  },
  {
    "title": "Config File",
    "heading": "Default Configuration",
    "content": "Below are the default configurations. Options commented out within transforms, processors and terser require peer dependencies to be installed for usage.",
    "url": "/usage/config-files#default-configuration"
  },
  {
    "title": "Versioning",
    "heading": "Versioning",
    "content": "",
    "url": "/cli/versioning#versioning"
  },
  {
    "title": "Versioning",
    "heading": "Semantic",
    "content": "",
    "url": "/cli/versioning#semantic"
  },
  {
    "title": "Versioning",
    "heading": "Examples",
    "content": "",
    "url": "/cli/versioning#examples"
  },
  {
    "title": "Versioning",
    "heading": "--patch",
    "content": "",
    "url": "/cli/versioning#--patch"
  },
  {
    "title": "Versioning",
    "heading": "--minor",
    "content": "",
    "url": "/cli/versioning#--minor"
  },
  {
    "title": "Versioning",
    "heading": "--major",
    "content": "",
    "url": "/cli/versioning#--major"
  },
  {
    "title": "Directory Structure",
    "heading": "Project Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/project-structures#project-structures"
  },
  {
    "title": "Directory Structure",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/project-structures#base-directories"
  },
  {
    "title": "Directory Structure",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/project-structures#input--output"
  },
  {
    "title": "Directory Structure",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/project-structures#default-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Structure",
    "content": "",
    "url": "/usage/project-structures#structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/project-structures#configuration"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/project-structures#custom-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/project-structures#customized-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/project-structures#output-structure"
  },
  {
    "title": "Directory Structure",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/project-structures#paths"
  },
  {
    "title": "Directory Structure",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/project-structures#config-file"
  },
  {
    "title": "Directory Structure",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/project-structures#custom-structures"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript",
    "content": "Syncify supports JavaScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#javascript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Example",
    "content": "Generate an starting point strap example with JavaScript transforms pre-configured:",
    "url": "/usage/transforms/javascript#example"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using jsconfig file",
    "content": "When leveraging Syncify to bundle JavaScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-jsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "JavaScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#javascript-transform"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript",
    "content": "Syncify supports TypeScript bundling, tree-shaking, code splitting and minification out of the box. Under the hood, Syncify leverages [ESBuild](https://esbuild.github.io/) and the script transform configuration option allows developers to process JavaScript in a fast and effecient manner. Syncify script tranforms apply compatible presets for handling JavaScript files with ESBuild and provides developers distribution control with support for snippet generation.",
    "url": "/usage/transforms/javascript#typescript"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "Using tsconfig file",
    "content": "When leveraging Syncify to bundle TypeScript files, it is recommended that you include a jsconfig.json file within the root of your project. Syncify will automatically detect jsconfig.json files and inherit bundle specific settings from within. The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context.",
    "url": "/usage/transforms/javascript#using-tsconfig-file"
  },
  {
    "title": "Transforms - JavaScript",
    "heading": "TypeScript Transform",
    "content": "You may prefer to use rename (entry point) structures instead. When we are using rename entry points the prefix path expects either snippets/ or assets/ be provided. When passing snippets/ then a snippet will be generated, whereas assets/ will generate a .js file.",
    "url": "/usage/transforms/javascript#typescript-transform"
  },
  {
    "title": "Directory Structures",
    "heading": "Directory Structures",
    "content": "Syncify requires you to define custom base directory paths that point to theme files. The values you provide will refer to a directory name that is relative to the root of your project. You cannot define multi-level directories (e.g: some/dir) or reverse paths (e.g: ../dir). You can pass these references within a syncify configuration file or via the CLI.",
    "url": "/usage/directory-structures#directory-structures"
  },
  {
    "title": "Directory Structures",
    "heading": "Base Directories",
    "content": "Below is an example of a Syncify theme structure using the defaults. Syncify will assume this base structure when you do not provide any customizations via the CLI or within your syncify config file.",
    "url": "/usage/directory-structures#base-directories"
  },
  {
    "title": "Directory Structures",
    "heading": "Input → Output",
    "content": "Single directory structures are not a viable approach when building modern and performant Shopify themes. Client-side (front-end) development is not SaaS specific and thus, with the proper tooling, Shopify theme development does not require one to adhere to the imposed approach of Shopify Dawn (via Shopify CLI). The argument for multi-directory architecture rests upon the millions of projects which isolate source ~ distribution variations and appropriate such logic. If you have become accustomed to working from a single directory structure (i.e: Shopify Dawn) it is important that you understand the difference between the input and output directory approach.",
    "url": "/usage/directory-structures#input--output"
  },
  {
    "title": "Directory Structures",
    "heading": "Default Structure",
    "content": "The structure which syncify will default.",
    "url": "/usage/directory-structures#default-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Structure",
    "content": "",
    "url": "/usage/directory-structures#structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Configuration",
    "content": "Below are 2 different input structures and an output structure. The default structure is what Syncify will use (as above) if no paths have been defined in your configuration (the tool defaults to this). The customized structure is an example of how you could arrange an input directory using the Syncify paths option. The output structure is what Syncify will generated as an output which Shopify can digest.",
    "url": "/usage/directory-structures#configuration"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structure",
    "content": "Using the default structure is certainly not the preferred approach when leveraging Syncify and you are encouraged to establish an input (theme) structure which suits your project and adheres to your workflow or tastes. Below is a basic example of how we can architect a customized structure using the paths option.",
    "url": "/usage/directory-structures#custom-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Customized Structure",
    "content": "An example of how you could structure themes.",
    "url": "/usage/directory-structures#customized-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Output Structure",
    "content": "There is no distributed difference between the default and customized structures illustrated above. Both would generate an output that Shopify understands, requires and reasons with. Only the input source locations differ. The output Syncify creates will always be written to a standard Shopify theme structure regardless of how you may decide to organize input paths. Custom structures give you creative freedom and does not impose a restrictive workflow you may have become behest to working with Dawn and the Shopify CLI.",
    "url": "/usage/directory-structures#output-structure"
  },
  {
    "title": "Directory Structures",
    "heading": "Paths",
    "content": "There is no restrictions or limitations imposed on structures other than input relativity. Syncify will obtain full resolution and build a valid theme structure that Shopify understands when generating an output.",
    "url": "/usage/directory-structures#paths"
  },
  {
    "title": "Directory Structures",
    "heading": "Config File",
    "content": "By default, Syncify assumes you are using a basic (defaults) structure. This structure is certainly not the preferred format and when leveraging Syncify you are encouraged to establish a structure which suits your project and adheres to your workflow or tastes.",
    "url": "/usage/directory-structures#config-file"
  },
  {
    "title": "Directory Structures",
    "heading": "Custom Structures",
    "content": "Welcome to the better approach, you're welcome.",
    "url": "/usage/directory-structures#custom-structures"
  }
]